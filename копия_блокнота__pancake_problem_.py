# -*- coding: utf-8 -*-
"""Копия блокнота "Pancake Problem"

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/11pfe1vERsVHOhFEijmaIuyTo1zEuAzFO

# Pancake Problem: Baseline Submission

This notebook demonstrates a simple pancake-sort baseline that generates a Kaggle submission.
Moves use the prefix-reversal notation `Rk`, where `Rk` flips the first `k` elements of a state.

The work was carried out in a Docker image, so some commands for working with files may be unclear.
"""

from __future__ import annotations

import pandas as pd
import numpy as np

from pathlib import Path
from typing import Iterable

from tqdm.notebook import tqdm

import gc

# Detect Kaggle environment ( /kaggle/input/... ), otherwise fall back to local repo layout.
DATA_ROOT = Path('/content/Pancake')
TEMP_ROOT = Path('/content/Pancake/Temp')
assert DATA_ROOT.exists(), f'Dataset directory not found: {DATA_ROOT!s}'

TEST_PATH = DATA_ROOT / 'test.csv'
SUBMISSION_PATH = DATA_ROOT / 'submission.csv' # Kaggle expects this in the working directory
BEST_SUBMISSION_PATH = DATA_ROOT / 'collect_best.csv'

test_df = pd.read_csv(TEST_PATH)
best_df = pd.read_csv(BEST_SUBMISSION_PATH)

"""## def"""

def parse_permutation(raw: str) -> list[int]:
    """Parse a comma-separated permutation string into integer positions."""
    return [int(token) for token in raw.split(',') if token]

def pancake_sort_path(perm: Iterable[int]) -> list[str]:
    """Return a sequence of prefix reversals that sorts `perm` to the identity permutation."""
    arr = list(perm)
    n = len(arr)
    moves: list[str] = []

    for target in range(n, 1, -1):
        desired_value = target - 1
        idx = arr.index(desired_value)

        if idx == target - 1:
            continue  # already in place

        if idx != 0:
            moves.append(f'R{idx + 1}')
            arr[: idx + 1] = reversed(arr[: idx + 1])

        moves.append(f'R{target}')
        arr[:target] = reversed(arr[:target])

    return moves

def pancake_sort_input(perm: Iterable[int]) -> list[str]:
    """Return a sequence of prefix reversals that sorts `perm` to the identity permutation."""
    arr = list(perm)
    n = len(arr)
    moves: list[str] = []

    print(f'Len: {n}, Permutation: {arr}')
    move = int(input(f'Move:{len(moves) + 1:2d} | R:').strip())

    while move:
        moves.append(f'R{move}')
        arr[: move] = reversed(arr[: move])
        print(arr)
        move = int(input(f'Move:{len(moves) + 1:2d} | R:'))

    return moves

def prob_step(perm):
    perm_ = perm.copy()
    n = len(perm_)
    k = perm_[-1] == n - 1
    k -= sum(perm_[:2]) == 1

    while len(perm_) - 1:
        m = perm_.pop()
        k += perm_[-1] - 1 == m or perm_[-1] + 1 == m
    return n - k

def compare():
    n_list = [5, 12, 15, 16, 20, 25, 30, 35, 40, 45, 50, 75, 100]
    for n in n_list:
        pos = (best_df.n == n)
        score = best_df.score[pos].sum()
        n_sum = best_df.n[pos].sum()
        prob_step = best_df.prob_step[pos].sum()

        print(f'n: {n} | sum n: {n_sum} | score: {score} | prob step: {prob_step} | potential: {score - prob_step}')
    print()
    print(f'sum n: {best_df.n.sum()} | score: {best_df.score.sum()} | prob step: {best_df.prob_step.sum()}')

def best_solution(submission_df, best_df=None, safe=False):

    if best_df is None:
        best_df = pd.read_csv(BEST_SUBMISSION_PATH)

    best_df = best_df.set_index('id')
    submission_df = submission_df.set_index('id')

    common_idx = best_df.index.intersection(submission_df.index)

    same_score_idx = []
    best_score_idx = []

    for idx in common_idx:
        if best_df.loc[idx, 'score'] == submission_df.loc[idx, 'score']:
            same_score_idx.append(idx)

        if best_df.loc[idx, 'score'] > submission_df.loc[idx, 'score']:
            best_score_idx.append(idx)
            best_df.loc[idx, ['solution', 'score']] = submission_df.loc[idx, ['solution', 'score']]

    if safe and best_score_idx:
        best_df.to_csv(BEST_SUBMISSION_PATH)
        print('Best submission updated.')

    return best_df.reset_index().sort_values('id'), {'best': len(best_score_idx),
                                                     'same': len(same_score_idx),
                                                     'worse': len(common_idx) - len(best_score_idx) - len(same_score_idx)}

def process_row(row, func=None, treshold=3, save=False, from_target=False):

    perm = parse_permutation(row['permutation'])

    if from_target:
        perm = revers_perm(perm)

    moves, _, mlen, i = func(perm, treshold)

    if from_target:
        steps = moves[0][::-1]
    else:
        steps = moves[0]

    path_str = '.'.join(f'R{k}' for k in steps) if moves else 'UNSOLVED'

    if save:
        id_ = row['id']
        n = int(row['n'])
        print(f'id: {id_} - complete')

        with open(TEMP_ROOT / f'n_{n}.txt', mode='a') as file_:
            file_.write(f'{id_} - ' + path_str + '\n')

    return {
        'id': row['id'],
        'permutation': row['permutation'],
        'solution': path_str,
        'score': len(steps),
        'n': int(row['n']),
        'mlen': mlen,
        'iter': i
    }

def revers_perm(perm):
    code_dict = {}
    decode_dict = {}
    for i, n in enumerate(perm):
        code_dict[n] = i
        decode_dict[i] = n
    reversed_perm = [code_dict[i] for i in range(len(perm))]
    return reversed_perm, decode_dict

"""## Old versions

"""

def pancake_sort_v1(perm):
    """Return a sequence of prefix reversals that sorts `perm` to the identity permutation."""
    arr = list(perm)
    n = len(arr)
    moves: list[str] = []

    arr_max_len = 0

    permute_search = {tuple(arr):[]}

    target = tuple(i for i in range(n))

    def check_and_wrigth(arr_, idx):
        if not moves or (moves and moves[-1] != idx):
            arr_[: idx] = reversed(arr_[: idx])
            permute_search[tuple(arr_)] = moves + [idx]

    while target not in permute_search:

        stage_permute_search = permute_search.copy()

        for arr in stage_permute_search:

            moves = permute_search[arr]

            left_arr = list(arr)
            rigth_arr = list(arr)
            revers_arr = list(arr)

            left_value = left_arr[0] - 1 if left_arr[0] > 0 else left_arr[0]
            rigth_value = rigth_arr[0] + 1 if rigth_arr[0] < n - 1 else None

            left_idx = left_arr.index(left_value)
            rigth_idx = rigth_arr.index(rigth_value) if rigth_value else n

            check_and_wrigth(left_arr, left_idx)

            check_and_wrigth(rigth_arr, rigth_idx)

            if revers_arr[0] - 1 == revers_arr[1]:
                for i in range(2, n):
                    if revers_arr[i - 1] - 1 != revers_arr[i]:
                        check_and_wrigth(revers_arr, i)
                        break

            elif revers_arr[0] + 1 == revers_arr[1]:
                for i in range(2, n):
                    if revers_arr[i - 1] + 1 != revers_arr[i]:
                        check_and_wrigth(revers_arr, i)
                        break

            arr_max_len = max(arr_max_len, len(permute_search))
            permute_search.pop(arr)

    return permute_search[target], arr_max_len

def pancake_sort_v2(perm):
    """Return a sequence of prefix reversals that sorts `perm` to the identity permutation."""
    arr = list(perm)
    n = len(arr)
    moves: list[int] = []

    arr_max_len = 0

    permute_search = {tuple(arr):[]}

    target = tuple(i for i in range(n))

    def check_and_wrigth(idx):
        arr_ = list_arr.copy()
        if not moves or (moves and moves[-1] != idx):
            arr_[: idx] = reversed(arr_[: idx])
            if tuple(arr_) not in permute_search:
                permute_search[tuple(arr_)] = moves + [idx]

    while target not in permute_search:

        stage_permute_search = permute_search.copy()

        for arr in stage_permute_search:

            moves = permute_search[arr]
            list_arr = list(arr)

            left_value = list_arr[0] - 1 if list_arr[0] > 0 else list_arr[0]
            rigth_value = list_arr[0] + 1 if list_arr[0] < n - 1 else None

            left_idx = list_arr.index(left_value)
            rigth_idx = list_arr.index(rigth_value) if rigth_value else n

            check_and_wrigth(left_idx)
            check_and_wrigth(rigth_idx)

            if list_arr[0] - 1 == list_arr[1]:
                for i in range(2, n):
                    if list_arr[i - 1] - 1 != list_arr[i]:
                        check_and_wrigth(i)
                        break

            elif list_arr[0] + 1 == list_arr[1]:
                for i in range(2, n):
                    if list_arr[i - 1] + 1 != list_arr[i]:
                        check_and_wrigth(i)
                        break

            arr_max_len = max(arr_max_len, len(permute_search))
            permute_search.pop(arr)

    return permute_search[target], arr_max_len

def pancake_sort_v2_1(perm):
    """Return a sequence of prefix reversals that sorts `perm` to the identity permutation."""
    arr = list(perm)
    n = len(arr)

    arr_max_len = 0
    div = 0
    total_iter = 0

    permute_search = {tuple(arr):((), 0)}

    target = tuple(i for i in range(n))

    def check_and_wrigth(idx, _div=0):
        if not moves or (moves and moves[-1] != idx):
            arr_ = tuple(list_arr[idx-1::-1] + list_arr[idx:])
            if arr_ not in permute_search:
                permute_search[arr_] = (moves + (idx,), stat + _div)

    while target not in permute_search:

        stage_permute_search = permute_search.copy()

        for arr in stage_permute_search:

            total_iter += 1

            moves = permute_search[arr][0]
            stat = permute_search[arr][1]
            list_arr = list(arr)

            left_value = list_arr[0] - 1 if list_arr[0] > 0 else 1
            rigth_value = list_arr[0] + 1 if list_arr[0] < n - 1 else None

            left_idx = list_arr.index(left_value)
            rigth_idx = list_arr.index(rigth_value) if rigth_value else n

            if left_idx != 1 and list_arr[left_idx - 1] + 1 == left_value:
                div = 1
            else:
                div = 0

            check_and_wrigth(left_idx, div)


            if rigth_idx != 1 and list_arr[rigth_idx - 1] - 1 == rigth_value:
                div = 1
            else:
                div = 0

            check_and_wrigth(rigth_idx, div)

            if list_arr[0] - 1 == list_arr[1]:
                for i in range(2, n):
                    if list_arr[i - 1] - 1 != list_arr[i]:
                        check_and_wrigth(i)
                        break

            elif list_arr[0] + 1 == list_arr[1]:
                for i in range(2, n):
                    if list_arr[i - 1] + 1 != list_arr[i]:
                        check_and_wrigth(i)
                        break

            arr_max_len = max(arr_max_len, len(permute_search))
            permute_search.pop(arr)

    return permute_search[target], permute_search, arr_max_len, total_iter

def pancake_sort_v2_2_np(perm):
    """Return a sequence of prefix reversals that sorts `perm` to the identity permutation."""
    arr = np.array(perm, dtype=np.uint8)
    n = len(arr)

    arr_max_len = 0
    div = 0
    total_iter = 0

    permute_search = {arr.tobytes():([], 0)}

    target = np.arange(n, dtype=np.uint8).tobytes()

    def check_and_wrigth(idx, _div=0):
        if not moves or (moves and moves[-1] != idx):
            arr_ = np.concat([arr[idx-1:: -1], arr[idx:]])
            if arr_.tobytes() not in permute_search:
                permute_search[arr_.tobytes()] = [moves + [idx], stat + _div]

    while target not in permute_search:

        stage_permute_search = permute_search.copy()

        for arr_b in stage_permute_search:

            total_iter += 1

            moves = permute_search[arr_b][0]
            stat = permute_search[arr_b][1]

            arr = np.frombuffer(arr_b, dtype=np.uint8)

            left_value = arr[0] - 1 if arr[0] > 0 else None
            rigth_value = arr[0] + 1 if arr[0] < n - 1 else None

            left_idx = np.where(arr==left_value)[0][0] if left_value is not None else 1
            rigth_idx = np.where(arr==rigth_value)[0][0] if rigth_value else n

            if left_idx != 1 and arr[left_idx - 1] + 1 == left_value:
                div = 1
            else:
                div = 0

            check_and_wrigth(left_idx, div)


            if rigth_idx != 1 and rigth_value and arr[rigth_idx - 1] == rigth_value + 1:
                div = 1
            else:
                div = 0

            check_and_wrigth(rigth_idx, div)

            if arr[0] == arr[1] + 1:
                for i in range(2, n):
                    if arr[i - 1] != arr[i] + 1:
                        check_and_wrigth(i)
                        break

            elif arr[0] + 1 == arr[1]:
                for i in range(2, n):
                    if arr[i - 1] + 1 != arr[i]:
                        check_and_wrigth(i)
                        break

            arr_max_len = max(arr_max_len, len(permute_search))
            permute_search.pop(arr_b)

    return permute_search[target], permute_search, arr_max_len, total_iter

def pancake_sort_v3(perm):
    """Return a sequence of prefix reversals that sorts `perm` to the identity permutation."""
    arr = list(perm)
    n = len(arr)

    arr_max_len = 0
    total_iter = 0

    permute_search = {tuple(arr):((), 0)}

    target = tuple(i for i in range(n))

    def check_and_write(idx):
        if not moves or (moves and moves[-1] != idx):
            arr_ = tuple(list_arr[idx-1::-1] + list_arr[idx:])
            if arr_ not in permute_search:
                permute_search[arr_] = (moves + (idx,), 0)

    while target not in permute_search:

        stage_permute_search = permute_search.copy()

        for arr in stage_permute_search:

            total_iter += 1

            moves = permute_search[arr][0]

            list_arr = list(arr)

            # value < arr[0] : left
            left_value = list_arr[0] - 1 if list_arr[0] else None

            left_idx = list_arr.index(left_value) if left_value is not None else None

            if left_idx and left_idx == 1:
                for i in range(2, n):
                    if list_arr[i - 1] - 1 != list_arr[i]:
                        check_and_write(i)
                        break
            elif left_idx and list_arr[left_idx - 1] + 1 != left_value:
                check_and_write(left_idx)
            elif left_idx:
                check_and_write(left_idx + 1)

            # arr[0] < value : rigth
            rigth_value = list_arr[0] + 1 if list_arr[0] < n - 1 else None

            rigth_idx = list_arr.index(rigth_value) if rigth_value else n

            if rigth_idx == 1:
                for i in range(2, n):
                    if list_arr[i - 1] + 1 != list_arr[i]:
                        check_and_write(i)
                        break
            elif not rigth_value or list_arr[rigth_idx - 1] - 1 != rigth_value:
                check_and_write(rigth_idx)
            elif rigth_value:
                check_and_write(rigth_idx + 1)

            arr_max_len = max(arr_max_len, len(permute_search))
            permute_search.pop(arr)

    return permute_search[target], permute_search, arr_max_len, total_iter

def pancake_sort_v3_1(perm, treshold=3):
    """Return a sequence of prefix reversals that sorts `perm` to the identity permutation."""
    arr = list(perm)
    n = len(arr)

    arr_max_len = 0
    total_iter = 0

    permute_search = {tuple(arr):((), 0)}

    target = tuple(i for i in range(n))

    def check_and_write(idx, _div=0):
        _stat = stat + _div
        if (not moves or (moves and moves[-1] != idx)) and min_stat + treshold >= _stat:
            arr_ = tuple(list_arr[idx-1::-1] + list_arr[idx:])
            if arr_ not in permute_search or (len(permute_search[arr_][0]) > len(moves) and permute_search[arr_][1] > _stat):
                permute_search[arr_] = (moves + (idx,), _stat)

    while target not in permute_search:

        stage_permute_search = permute_search.copy()

        min_stat = min(i[1] for i in permute_search.values())

        for arr in stage_permute_search:

            total_iter += 1

            moves = permute_search[arr][0]
            stat = permute_search[arr][1]

            list_arr = list(arr)

            # value < arr[0] : left
            left_value = list_arr[0] - 1 if list_arr[0] else None

            left_idx = list_arr.index(left_value) if left_value is not None else None

            if left_idx and left_idx == 1:
                for i in range(2, n):
                    if list_arr[i - 1] - 1 != list_arr[i]:
                        check_and_write(i, 2)
                        break
            elif left_idx and list_arr[left_idx - 1] + 1 != left_value:
                check_and_write(left_idx, 1)
            elif left_idx:
                check_and_write(left_idx + 1, 3)

            # arr[0] < value : rigth
            rigth_value = list_arr[0] + 1 if list_arr[0] < n - 1 else None

            rigth_idx = list_arr.index(rigth_value) if rigth_value else n

            if rigth_idx == 1:
                for i in range(2, n):
                    if list_arr[i - 1] + 1 != list_arr[i]:
                        check_and_write(i, 2)
                        break
            elif not rigth_value or list_arr[rigth_idx - 1] - 1 != rigth_value:
                check_and_write(rigth_idx, 1)
            elif rigth_value:
                check_and_write(rigth_idx + 1, 2)

            arr_max_len = max(arr_max_len, len(permute_search))
            permute_search.pop(arr)

    return permute_search[target], permute_search, arr_max_len, total_iter

def pancake_sort_v3_3(perm, treshold=3):
    """Return a sequence of prefix reversals that sorts `perm` to the identity permutation."""
    arr = list(perm)
    n = len(arr)

    arr_max_len = 0
    total_iter = 0

    permute_search = {tuple(arr):((), 0, 0)}

    target = tuple(i for i in range(n))

    def check_last(perm_, last_):
        while perm_[n - 1 - last_] == n - 1 - last_:
            last_ += 1
        return last_


    def check_and_write(idx, _div=0):
        _stat = stat + _div
        if (not moves or (moves and moves[-1] != idx)) and min_stat + treshold >= _stat:
            arr_ = tuple(list_arr[idx-1::-1] + list_arr[idx:])
            last_ = check_last(arr_, last)
            if (arr_ not in permute_search  and last_ >= max_last) or (arr_ in permute_search and len(permute_search[arr_][0]) > len(moves) and permute_search[arr_][1] > _stat):
                permute_search[arr_] = (moves + (idx,), _stat, last_)

    while target not in permute_search:

        stage_permute_search = permute_search.copy()

        min_stat = min(i[1] for i in permute_search.values())
        max_last = sum(i[2] for i in permute_search.values()) // n

        for arr in stage_permute_search:

            total_iter += 1

            moves = permute_search[arr][0]
            stat = permute_search[arr][1]
            last = permute_search[arr][2]

            list_arr = list(arr)

            # value < arr[0] : left
            left_value = list_arr[0] - 1 if list_arr[0] else None
            left_idx = list_arr.index(left_value) if left_value is not None else None

            # arr[0] < value : rigth
            rigth_value = list_arr[0] + 1 if list_arr[0] < n - 1 else None
            rigth_idx = list_arr.index(rigth_value) if rigth_value else n

            if rigth_idx == 1:
                if list_arr[0] == 0:
                    for i in range(1, n):
                        if list_arr[-i] != n - i:
                            check_and_write(n - i + 1, 2)
                            break
                else:
                    for i in range(2, n):
                        if list_arr[i - 1] + 1 != list_arr[i]:
                            check_and_write(i, 2)
                            break
            elif not rigth_value or list_arr[rigth_idx - 1] - 1 != rigth_value:
                check_and_write(rigth_idx, 1)
            elif rigth_value:
                check_and_write(rigth_idx, 3)

            if left_idx and left_idx == 1:
                for i in range(2, n):
                    if list_arr[i - 1] - 1 != list_arr[i]:
                        check_and_write(i, 2)
                        break
            elif left_idx and list_arr[left_idx - 1] + 1 != left_value:
                check_and_write(left_idx, 1)
            elif left_idx:
                check_and_write(left_idx, 3)


            arr_max_len = max(arr_max_len, len(permute_search))
            permute_search.pop(arr)

    return permute_search[target], permute_search, arr_max_len, total_iter

def pancake_sort_v2_3(perm, treshold=9):
    """Return a sequence of prefix reversals that sorts `perm` to the identity permutation."""
    arr = list(perm)
    n = len(arr)

    arr_max_len = 0
    div = 0
    total_iter = 0
    moves = ()

    permute_search = {tuple(arr):((), 0)}

    target = tuple(i for i in range(n))

    def check_and_write(idx, _div=0):
        _stat = stat + _div
        if (not moves or (moves and moves[-1] != idx)) and min_stat + treshold >= _stat:
            arr_ = tuple(list_arr[idx-1::-1] + list_arr[idx:])
            if arr_ not in permute_search or (len(permute_search[arr_][0]) > len(moves) and permute_search[arr_][1] > _stat):
                permute_search[arr_] = (moves + (idx,), _stat)

    while target not in permute_search:

        stage_permute_search = permute_search.copy()

        min_stat = min(i[1] for i in permute_search.values())


        for arr in stage_permute_search:

            total_iter += 1

            moves = permute_search[arr][0]
            stat = permute_search[arr][1]

            list_arr = list(arr)

            left_value = list_arr[0] - 1 if list_arr[0] > 0 else 1
            rigth_value = list_arr[0] + 1 if list_arr[0] < n - 1 else None

            left_idx = list_arr.index(left_value)
            rigth_idx = list_arr.index(rigth_value) if rigth_value else n

            if left_idx != 1 and list_arr[left_idx - 1] + 1 == left_value:
                div = 2
            else:
                div = 1

            check_and_write(left_idx, div)


            if rigth_idx != 1 and list_arr[rigth_idx - 1] - 1 == rigth_value:
                div = 2
            else:
                div = 1

            check_and_write(rigth_idx, div)

            if list_arr[0] - 1 == list_arr[1]:
                for i in range(2, n):
                    if list_arr[i - 1] - 1 != list_arr[i]:
                        check_and_write(i, 2)
                        break

            elif list_arr[0] + 1 == list_arr[1]:
                for i in range(2, n):
                    if list_arr[i - 1] + 1 != list_arr[i]:
                        check_and_write(i, 2)
                        break

            arr_max_len = max(arr_max_len, len(permute_search))
            permute_search.pop(arr)

    return permute_search[target], permute_search, arr_max_len, total_iter

def pancake_sort_v3_2(perm, treshold=3):
    """Return a sequence of prefix reversals that sorts `perm` to the identity permutation."""
    arr = list(perm)
    n = len(arr)

    arr_max_len = 0
    total_iter = 0

    # permute_search = {tuple(arr):((), 0)}
    permute_search = {tuple(arr):((), 0), tuple(reversed(arr)):((n,), 0)}

    target = tuple(i for i in range(n))

    def check_and_write(idx, _div=0):
        _stat = stat + _div
        if (not moves or (moves and moves[-1] != idx)) and min_stat + treshold >= _stat:
            arr_ = tuple(list_arr[idx-1::-1] + list_arr[idx:])
            if arr_ not in permute_search or (len(permute_search[arr_][0]) > len(moves) and permute_search[arr_][1] > _stat):
                permute_search[arr_] = (moves + (idx,), _stat)

    while permute_search and target not in permute_search:

        min_stat = min(i[1] for i in permute_search.values())

        for arr in list(permute_search):

            total_iter += 1

            moves = permute_search[arr][0]
            stat = permute_search[arr][1]

            list_arr = list(arr)

            # value < arr[0] : left
            left_value = list_arr[0] - 1 if list_arr[0] else None
            left_idx = list_arr.index(left_value) if left_value is not None else None

            # arr[0] < value : rigth
            rigth_value = list_arr[0] + 1 if list_arr[0] < n - 1 else None
            rigth_idx = list_arr.index(rigth_value) if rigth_value else n

            if rigth_idx == 1:
                if list_arr[0] == 0:
                    for i in range(1, n):
                        if list_arr[-i] != n - i:
                            check_and_write(n - i + 1, 2)
                            break
                else:
                    for i in range(2, n):
                        if list_arr[i - 1] + 1 != list_arr[i]:
                            check_and_write(i, 2)
                            break

            elif not rigth_value or list_arr[rigth_idx - 1] - 1 != rigth_value:
                check_and_write(rigth_idx, 0)
            elif rigth_value:
                check_and_write(rigth_idx, 2)

            if left_idx and left_idx == 1:
                for i in range(2, n):
                    if list_arr[i - 1] - 1 != list_arr[i]:
                        check_and_write(i, 2)
                        break
            elif left_idx and list_arr[left_idx - 1] + 1 != left_value:
                check_and_write(left_idx, 0)
            elif left_idx:
                check_and_write(left_idx, 2)


            arr_max_len = max(arr_max_len, len(permute_search))
            permute_search.pop(arr)

        answer = permute_search.get(target)

    return answer, permute_search, arr_max_len, total_iter

def pancake_sort_v3_4(perm, treshold=3):
    """Return a sequence of prefix reversals that sorts `perm` to the identity permutation."""
    arr = list(perm)
    n = len(arr)

    arr_max_len = 0
    total_iter = 0

    permute_search = {tuple(arr):((), 0)}
    # permute_search = {tuple(arr):((), 0), tuple(reversed(arr)):((n,), 0)}

    target = tuple(i for i in range(n))

    def check_and_write(idx, _div=0):
        _stat = stat + _div
        if (not moves or (moves and moves[-1] != idx)) and min_stat + treshold >= _stat:
            arr_ = tuple(list_arr[idx-1::-1] + list_arr[idx:])
            if arr_ not in permute_search or (len(permute_search[arr_][0]) > len(moves) and permute_search[arr_][1] > _stat):
                permute_search[arr_] = (moves + (idx,), _stat)

    while target not in permute_search:

        # stage_permute_search = permute_search.copy()

        min_stat = min(i[1] for i in permute_search.values())

        for arr in list(permute_search):

            total_iter += 1

            moves = permute_search[arr][0]
            stat = permute_search[arr][1]

            rigth_step = False
            left_step = False

            list_arr = list(arr)

            # value < arr[0] : left
            left_value = list_arr[0] - 1 if list_arr[0] else None
            left_idx = list_arr.index(left_value) if left_value is not None else None

            # arr[0] < value : rigth
            rigth_value = list_arr[0] + 1 if list_arr[0] < n - 1 else None
            rigth_idx = list_arr.index(rigth_value) if rigth_value else n

            if rigth_idx == 1:
                for i in range(2, n):
                    if list_arr[i - 1] + 1 != list_arr[i]:
                        check_and_write(i, 2)
                        break
                # rigth_step = True
            elif not rigth_value or list_arr[rigth_idx - 1] - 1 != rigth_value:
                check_and_write(rigth_idx, 0)
                rigth_step = True

            if list_arr[0] == 0:
                for i in range(1, n):
                    if list_arr[-i] != n - i:
                        check_and_write(n - i + 1, 2)
                        break
                left_step = True
            elif left_idx and left_idx == 1:
                for i in range(2, n):
                    if list_arr[i - 1] - 1 != list_arr[i]:
                        check_and_write(i, 2)
                        break
                # left_step = True
            elif left_idx and list_arr[left_idx - 1] + 1 != left_value:
                check_and_write(left_idx, 0.2)
                left_step = True

            if left_step == False == rigth_step:
            # if not left_step or not rigth_step:
                if rigth_value:
                    # check_and_write(rigth_idx, 2)
                    # check_and_write(rigth_idx + 1, 2)
                    pass
                if left_idx:
                    # check_and_write(left_idx, 2)
                    # check_and_write(left_idx + 1, 2)
                    pass
                for i in range(1, n):
                    if list_arr[-i] != n - i:
                        if list_arr.index(n - i) != list_arr.index(n - i - 1) + 1:
                            check_and_write(list_arr.index(n - i) + 1, 2)
                        else:
                            check_and_write(n - i + 1, 2)
                        break



            arr_max_len = max(arr_max_len, len(permute_search))
            permute_search.pop(arr)

    return permute_search[target], permute_search, arr_max_len, total_iter

def pancake_sort_v3_3(perm, treshold=3):
    """Return a sequence of prefix reversals that sorts `perm` to the identity permutation."""
    arr = list(perm)
    n = len(arr)

    arr_max_len = 0
    total_iter = 0

    # permute_search = {tuple(arr):((), 0), tuple(reversed(arr)):((n,), 0)}
    permute_search = {tuple(arr):((), 0)}

    target = tuple(i for i in range(n))

    def check_and_write(idx, _div=0):
        _stat = stat + _div
        if (not moves or (moves and moves[-1] != idx)) and min_stat + treshold >= _stat:
            arr_ = tuple(list_arr[idx-1::-1] + list_arr[idx:])
            if arr_ not in permute_search or (len(permute_search[arr_][0]) > len(moves) and permute_search[arr_][1] > _stat):
                permute_search[arr_] = (moves + (idx,), _stat)

    def mask_step(perm):
            perm_ = perm.copy()
            n = len(perm_)
            step = [] if perm_[n-1] == n-1 else [n]

            while len(perm_) - 2:
                m = perm_.pop()
                if not (perm_[-1] - 1 == m or perm_[-1] + 1 == m):
                    step.append(len(perm_))
            return step


    while target not in permute_search:

        # stage_permute_search = permute_search.copy()

        min_stat = min(i[1] for i in permute_search.values())

        for arr in list(permute_search):

            total_iter += 1

            moves = permute_search[arr][0]
            stat = permute_search[arr][1]

            list_arr = list(arr)

            rigth_step = False
            left_step = False

            # value < arr[0] : left
            left_value = list_arr[0] - 1 if list_arr[0] else None
            left_idx = list_arr.index(left_value) if left_value is not None else None

            # arr[0] < value : rigth
            rigth_value = list_arr[0] + 1 if list_arr[0] < n - 1 else None
            rigth_idx = list_arr.index(rigth_value) if rigth_value else n

            if not rigth_value or (rigth_idx != 1 and list_arr[rigth_idx - 1] - 1 != rigth_value):
                check_and_write(rigth_idx, 0)
                rigth_step = True

            if left_idx and left_idx != 1 and list_arr[left_idx - 1] + 1 != left_value:
                check_and_write(left_idx, 0.2)
                left_step = True

            if not rigth_step or not left_step:
                for i in mask_step(list_arr):
                    check_and_write(i, 2)

            arr_max_len = max(arr_max_len, len(permute_search))
            permute_search.pop(arr)

    return permute_search[target], permute_search, arr_max_len, total_iter

def pancake_sort_v3_5_np(perm, treshold=10):
    """Return a sequence of prefix reversals that sorts `perm` to the identity permutation."""
    arr = np.array(perm, dtype=np.uint8)
    n = len(arr)

    arr_max_len = 0
    total_iter = 0

    permute_search = {arr.tobytes(): (np.array([], dtype=np.uint8), 0)}

    target = np.arange(n, dtype=np.uint8).tobytes()

    def check_and_write(idx, _div=0):
        _stat = stat + _div
        if (not moves.size or (moves.size and moves[-1] != idx)) and min_stat + treshold >= _stat:
            arr_ = np.concatenate([list_arr[idx-1::-1], list_arr[idx:]])
            arr_ = arr_.tobytes()
            old = permute_search.get(arr_)
            if not old:
                permute_search[arr_] = (np.concatenate([moves, np.array([idx], dtype=np.uint8)], axis=0), _stat)
            else:
                old_moves, old_stat = old
                if len(old_moves) > len(moves) and old_stat > _stat:
                    permute_search[arr_] = (moves + (idx,), _stat)

    def mask_step(perm):
            perm_ = perm.copy()
            n = len(perm_)
            step = [] if perm_[n-1] == n-1 else [n]

            while len(perm_) - 2:
                m = perm_[-1:]
                perm_ = perm_[:-1]
                if not (perm_[-1] - 1 == m or perm_[-1] + 1 == m):
                    step.append(len(perm_))
            return step


    while target not in permute_search:

        min_stat = min(i[1] for i in permute_search.values())

        for arr in list(permute_search):

            total_iter += 1

            moves = permute_search[arr][0]
            stat = permute_search[arr][1]

            list_arr = np.frombuffer(arr, dtype=np.int8)

            rigth_step = False
            left_step = False

            # value < arr[0] : left
            left_value = list_arr[0] - 1 if list_arr[0] else None
            left_idx = np.where(list_arr==left_value)[0][0] if left_value is not None else None

            # arr[0] < value : rigth
            rigth_value = list_arr[0] + 1 if list_arr[0] < n - 1 else None
            rigth_idx = np.where(list_arr==rigth_value)[0][0] if rigth_value else n

            if not rigth_value or (rigth_idx != 1 and list_arr[rigth_idx - 1] - 1 != rigth_value):
                check_and_write(rigth_idx, 10 / n)
                rigth_step = True
            elif rigth_idx != 1:
                check_and_write(rigth_idx, 10)

            if left_idx and left_idx != 1 and list_arr[left_idx - 1] + 1 != left_value:
                check_and_write(left_idx, 10 / n)
                left_step = True
            elif left_idx and left_idx != 1:
                check_and_write(left_idx, 10)

            if not rigth_step or not left_step:
                for i in mask_step(list_arr):
                    check_and_write(i, 10)

            arr_max_len = max(arr_max_len, len(permute_search))
            permute_search.pop(arr)

    return permute_search[target], None, arr_max_len, total_iter

def pancake_sort_v3_5(perm, treshold=3):
    """Return a sequence of prefix reversals that sorts `perm` to the identity permutation."""
    arr = list(perm)
    n = len(perm)

    arr_max_len = 0
    total_iter = 0

    # permute_search = {tuple(arr):((), 0), tuple(reversed(arr)):((n,), 0)}
    permute_search = {tuple(perm):((), 0)}

    target = tuple(i for i in range(n))

    def check_and_write(idx, _div=0):
        _stat = stat + _div
        if (not moves or (moves and moves[-1] != idx)) and min_stat + treshold >= _stat:
            arr_ = tuple(list_arr[idx-1::-1] + list_arr[idx:])
            if arr_ not in permute_search or (len(permute_search[arr_][0]) > len(moves) and permute_search[arr_][1] > _stat):
                permute_search[arr_] = (moves + (idx,), _stat)

    def mask_step(perm):
            perm_ = perm.copy()
            n = len(perm_)
            step = [] if perm_[n-1] == n-1 else [n]

            while len(perm_) - 2:
                m = perm_.pop()
                if not (perm_[-1] - 1 == m or perm_[-1] + 1 == m):
                    step.append(len(perm_))
            return step


    while target not in permute_search:

        min_stat = min(i[1] for i in permute_search.values())

        for arr in list(permute_search):

            total_iter += 1

            moves = permute_search[arr][0]
            stat = permute_search[arr][1]

            list_arr = list(arr)

            rigth_step = False
            left_step = False

            # value < arr[0] : left
            left_value = list_arr[0] - 1 if list_arr[0] else None
            left_idx = list_arr.index(left_value) if left_value is not None else None

            # arr[0] < value : rigth
            rigth_value = list_arr[0] + 1 if list_arr[0] < n - 1 else None
            rigth_idx = list_arr.index(rigth_value) if rigth_value else n

            if not rigth_value or (rigth_idx != 1 and list_arr[rigth_idx - 1] - 1 != rigth_value):
                check_and_write(rigth_idx, 10 / n)
                rigth_step = True
            elif rigth_idx != 1:
                check_and_write(rigth_idx, 10)

            if left_idx and left_idx != 1 and list_arr[left_idx - 1] + 1 != left_value:
                check_and_write(left_idx, 10 / n)
                left_step = True
            elif left_idx and left_idx != 1:
                check_and_write(left_idx, 10)

            if not rigth_step or not left_step:
                for i in mask_step(list_arr):
                    check_and_write(i, 10)

            arr_max_len = max(arr_max_len, len(permute_search))
            permute_search.pop(arr)

    return permute_search[target], permute_search, arr_max_len, total_iter

def pancake_sort_recursive_v2(perm):
    n = len(perm)
    threshold = n + 2

    permute_complete = {}

    target = tuple(i for i in range(n))

    def mask_step(perm):
        perm_ = list(perm)
        n = len(perm_)
        step = [] if perm_[n - 1] == n - 1 else [n]

        while len(perm_) - 2:
            m = perm_.pop()
            if not (perm_[-1] - 1 == m or perm_[-1] + 1 == m):
                step.append(len(perm_))
        return step

    def move_recursive(arr, moves):

        if len(moves) >= threshold:
            return

        def check_and_write(idx):
            nonlocal threshold
            if not moves or (moves and moves[-1] != idx):
                arr_ = arr[idx - 1::-1] + arr[idx:]
                if arr_ == target:
                    permute_complete[moves + (idx,)] = len(moves) + 1
                    threshold = min(threshold, len(moves) + 1)
                else:
                    move_recursive(arr_, moves + (idx,))

        right_step = False
        left_step = False

        # value < arr[0] : left
        left_value = arr[0] - 1 if arr[0] else None
        left_idx = arr.index(left_value) if left_value is not None else None

        # arr[0] < value : right
        right_value = arr[0] + 1 if arr[0] < n - 1 else None
        right_idx = arr.index(right_value) if right_value else n

        if not right_value or (right_idx != 1 and arr[right_idx - 1] - 1 != right_value):
            check_and_write(right_idx)
            right_step = True
        elif right_idx != 1:
            check_and_write(right_idx)

        if left_idx and left_idx != 1 and arr[left_idx - 1] + 1 != left_value:
            check_and_write(left_idx)
            left_step = True
        elif left_idx and left_idx != 1:
            check_and_write(left_idx)

        if not right_step and not left_step:
            for i in mask_step(arr):
                check_and_write(i)

    move_recursive(tuple(perm), ())

    return permute_complete

"""## job

"""

def pancake_sort_v3_6(perm, treshold=10):
    """Return a sequence of prefix reversals that sorts `perm` to the identity permutation."""

    n = len(perm)

    arr_max_len = 0
    total_iter = 0
    new_min_stat = 0

    permute_search = {tuple(perm): ((), 0)}

    target = tuple(i for i in range(n))

    def check_and_write(idx, _div=0):
        nonlocal new_min_stat
        _stat = stat + _div
        if (not moves or (moves and moves[-1] != idx)) and min_stat + treshold >= _stat:
            arr_ = arr[idx - 1::-1] + arr[idx:]
            old_stat = permute_search.get(arr_)
            if not old_stat:
                permute_search[arr_] = (moves + (idx,), _stat)
                new_min_stat = min(new_min_stat, _stat)
            # elif len(old_stat[0]) > len(moves) and old_stat[1] > _stat:
            #     permute_search[arr_] = (moves + (idx,), _stat)
            #     new_min_stat = min(new_min_stat, _stat)

    def mask_step(perm):
        perm_ = list(perm)
        n = len(perm_)
        step = [] if perm_[n-1] == n-1 else [n]

        while len(perm_) - 2:
            m = perm_.pop()
            if not (perm_[-1] - 1 == m or perm_[-1] + 1 == m):
                step.append(len(perm_))
        return step

    while permute_search and target not in permute_search:

        min_stat = new_min_stat
        new_min_stat = min_stat + n

        for arr in list(permute_search):

            total_iter += 1

            moves = permute_search[arr][0]
            stat = permute_search[arr][1]

            right_step = False
            left_step = False

            # value < arr[0] : left
            left_value = arr[0] - 1 if arr[0] else None
            left_idx = arr.index(left_value) if left_value is not None else None

            # arr[0] < value : right
            right_value = arr[0] + 1 if arr[0] < n - 1 else None
            right_idx = arr.index(right_value) if right_value else n

            if not right_value or (right_idx != 1 and arr[right_idx - 1] - 1 != right_value):
                check_and_write(right_idx, 10 / n)
                right_step = True
            elif right_idx != 1:
                check_and_write(right_idx, 10)

            if left_idx and left_idx != 1 and arr[left_idx - 1] + 1 != left_value:
                check_and_write(left_idx, 10 / n)
                left_step = True
            elif left_idx and left_idx != 1:
                check_and_write(left_idx, 10)

            if not right_step and not left_step:
                for i in mask_step(arr):
                    check_and_write(i, 10)

            arr_max_len = max(arr_max_len, len(permute_search))
            permute_search.pop(arr)

    return permute_search[target], None, arr_max_len, total_iter

def pancake_sort_v4(perm, treshold=10):
    """Return a sequence of prefix reversals that sorts `perm` to the identity permutation."""

    n = len(perm)

    arr_max_len = 0
    total_iter = 0
    new_min_stat = 0

    permute_search = {tuple(perm): ((), 0, True)}

    target = tuple(i for i in range(n))

    def check_and_write(idx, _div=0, left_way=True):
        nonlocal new_min_stat
        _stat = stat + _div
        if (not moves or (moves and moves[-1] != idx)) and min_stat + treshold >= _stat:
            arr_ = arr[idx - 1::-1] + arr[idx:]
            old_stat = permute_search.get(arr_)
            if not old_stat:
                permute_search[arr_] = (moves + (idx,), _stat, left_way)
                new_min_stat = min(new_min_stat, _stat)

    def mask_step(perm):
        perm_ = list(perm)
        n = len(perm_)
        step = [] if perm_[n-1] == n-1 else [n]

        while len(perm_) - 2:
            m = perm_.pop()
            if not (perm_[-1] - 1 == m or perm_[-1] + 1 == m):
                step.append(len(perm_))
        return step

    while permute_search and target not in permute_search:

        min_stat = new_min_stat
        new_min_stat = min_stat + n

        for arr in list(permute_search):

            total_iter += 1

            moves, stat, way = permute_search[arr]

            right_step = False
            left_step = False

            # value < arr[0] : left
            left_value = arr[0] - 1 if arr[0] else None
            left_idx = arr.index(left_value) if left_value is not None else None

            # arr[0] < value : right
            right_value = arr[0] + 1 if arr[0] < n - 1 else None
            right_idx = arr.index(right_value) if right_value else n

            if not right_value or (right_idx != 1 and arr[right_idx - 1] - 1 != right_value):
                check_and_write(right_idx, 0.05)
                right_step = True
            elif right_idx != 1:
                check_and_write(right_idx, 2)

            if left_idx and left_idx != 1 and arr[left_idx - 1] + 1 != left_value:
                check_and_write(left_idx, 0.25)
                left_step = True
            elif left_idx and left_idx != 1:
                check_and_write(left_idx, 2)

            if not right_step or not left_step:
                for i in mask_step(arr):
                    check_and_write(i, 2)

            arr_max_len = max(arr_max_len, len(permute_search))
            permute_search.pop(arr)

    return permute_search[target], None, arr_max_len, total_iter

def pancake_sort_recursive_v1(perm):
    n = len(perm)

    permute_search = {}
    permute_complete = {}

    target = tuple(i for i in range(n))

    def mask_step(perm):
        perm_ = list(perm)
        n = len(perm_)
        step = [] if perm_[n-1] == n-1 else [n]

        while len(perm_) - 2:
            m = perm_.pop()
            if not (perm_[-1] - 1 == m or perm_[-1] + 1 == m):
                step.append(len(perm_))
        return step


    def move_recursive(arr, moves):


        def check_and_write(idx, moves_):
            if not moves or (moves and moves_[-1] != idx):
                arr_ = arr[idx - 1::-1] + arr[idx:]
                if arr_ == target:
                    permute_complete[moves_ + (idx,)] = (target, len(moves_) + 1)
                else:
                    move_recursive(arr_, moves_ + (idx,))


        # value < arr[0] : left
        left_value = arr[0] - 1 if arr[0] else None
        left_idx = arr.index(left_value) if left_value is not None else None

        # arr[0] < value : right
        right_value = arr[0] + 1 if arr[0] < n - 1 else None
        right_idx = arr.index(right_value) if right_value else n

        if not right_value or (right_idx != 1 and arr[right_idx - 1] - 1 != right_value):
            check_and_write(right_idx, moves)
        else:
            permute_search[arr] = moves, len(moves)

        if left_idx and left_idx != 1 and arr[left_idx - 1] + 1 != left_value:
            check_and_write(left_idx, moves)
        else:
            permute_search[arr] = moves, len(moves)

    move_recursive(tuple(perm), ())

    # return permute_search, permute_complete

    if permute_complete:
        return permute_complete, permute_search, None

    perm, decode_dict = revers_perm(perm)
    permute_search_forward = permute_search.copy()
    permute_search.clear()

    move_recursive(tuple(perm), ())

    if permute_complete:
        permute_complete_backward = {}
        while permute_complete:
            key, item = permute_complete.popitem()
            permute_complete_backward[key[::-1]] = item
        return permute_complete_backward, permute_search_forward, permute_search

    for row in permute_search.keys():
        for idx in mask_step(row):
            perm = tuple(decode_dict[i] for i in (row[idx - 1::-1] + row[idx:]))
            print(perm)
            if perm in permute_search_forward:
                steps = permute_search[row][0] + (idx,)
                steps = permute_search_forward[perm][0] + steps[::-1]
                permute_complete[steps] = target, len(steps)

    return permute_complete, permute_search_forward, permute_search

def pancake_sort_recursive_v3(perm):
    n = len(perm)

    permute_search = {}
    permute_complete = {}

    target = tuple(i for i in range(n))

    # ---------------------------------------------------------------------------------

    def mask_step(perm):
        perm_ = list(perm)
        n = len(perm_)
        step = [] if perm_[n-1] == n-1 else [n]

        while len(perm_) - 2:
            m = perm_.pop()
            if not (perm_[-1] - 1 == m or perm_[-1] + 1 == m):
                step.append(len(perm_))
        return step


    def move_recursive(arr, moves):


        def check_and_write(idx, moves_):
            if not moves or (moves and moves_[-1] != idx):
                arr_ = arr[idx - 1::-1] + arr[idx:]
                if arr_ == target:
                    permute_complete[moves_ + (idx,)] = (target, len(moves_) + 1)
                else:
                    move_recursive(arr_, moves_ + (idx,))


        # value < arr[0] : left
        left_value = arr[0] - 1 if arr[0] else None
        left_idx = arr.index(left_value) if left_value is not None else None

        # arr[0] < value : right
        right_value = arr[0] + 1 if arr[0] < n - 1 else None
        right_idx = arr.index(right_value) if right_value else n

        if not right_value or (right_idx != 1 and arr[right_idx - 1] - 1 != right_value):
            check_and_write(right_idx, moves)
        else:
            permute_search[arr] = moves, len(moves)

        if left_idx and left_idx != 1 and arr[left_idx - 1] + 1 != left_value:
            check_and_write(left_idx, moves)
        else:
            permute_search[arr] = moves, len(moves)

    # ---------------------------------------------------------------------------------

    move_recursive(tuple(perm), ())

    if permute_complete:
        return permute_complete, permute_search, None

    # ================

    permute_search_forward = permute_search.copy()
    permute_search.clear()

    for key in permute_search_forward.keys():
        perm, decode_dict = revers_perm(key)
        move_recursive(tuple(perm), ())


    move_recursive(tuple(perm), ())

    perm, decode_dict = revers_perm(perm)

    if permute_complete:
        permute_complete_backward = {}
        while permute_complete:
            key, item = permute_complete.popitem()
            permute_complete_backward[key[::-1]] = item
        return permute_complete_backward, permute_search_forward, permute_search

    for row in permute_search.keys():
        for idx in mask_step(row):
            perm = tuple(decode_dict[i] for i in (row[idx - 1::-1] + row[idx:]))
            print(perm)
            if perm in permute_search_forward:
                steps = permute_search[row][0] + (idx,)
                steps = permute_search_forward[perm][0] + steps[::-1]
                permute_complete[steps] = target, len(steps)

    return permute_complete, permute_search_forward, permute_search

idx = 335
best_df.iloc[idx]

# Переменные из предыдущих ячеек (при запуске как скрипт могут быть не определены)
permute_search = globals().get("permute_search", {})
del permute_search
gc.collect()

def print_search(perm_dict):
    if perm_dict:
        for key, item in perm_dict.items():
            print(f'{key} | {item}')
    else:
        print(None)

perm = [22, 1, 24,  5, 26,  3, 28, 9, 30, 7, 32, 13, 34, 11, 36, 17, 38,
       15, 40, 21, 42, 19,  0, 25,  2, 23,  4, 29,  6, 27,  8, 33, 10, 31,
       12, 37, 14, 35, 16, 41, 18, 39, 20]



# Commented out IPython magic to ensure Python compatibility.
# %%time
# # perm = parse_permutation(test_df.iloc[idx].permutation)
# # perm, _= revers_perm(perm)
# r, permute, p, i = pancake_sort_v4(perm, 3)
# print(perm)
# print(f'Len: {len(perm)} | Steps: {len(r[0])} | max line: {p} | iter: {i}')
# print(r, '\n')
#

perm, _ = revers_perm((7, 6, 5, 4, 9, 8, 3, 2, 1, 0, 10, 11, 12, 13, 14))

(15, 6, 12, 7, 5, 3, 11, 13, 3, 14, 3, 4, 6, 2, 10)

(15, 6, 12, 7, 5, 3, 11, 13, 3, 14, 3)

pancake_sort_input(perm)

# Commented out IPython magic to ensure Python compatibility.
# %%time
# perm = parse_permutation(test_df.iloc[idx].permutation)
# permute_complete, permute_search_forward, permute_search = pancake_sort_recursive_v1(perm)

permute_complete = globals().get("permute_complete", {})
permute_search_forward = globals().get("permute_search_forward", {})
permute_search = globals().get("permute_search", {})
print_search(permute_complete)
print_search(permute_search_forward)
print_search(permute_search)

test_df_ = test_df[405:605] # 16

test_df_ = test_df[605:805] # 20

test_df_ = test_df[805:1005] # 25

test_df_ = test_df[1005:1205] # 30 - 12

test_df_ = test_df[1205:1405] # 35 - 12

test_df_ = test_df[1405:1605] # 40 - 12

test_df_ = test_df[1605:1805] # 45 - 12

test_df_ = test_df[1805:2005] # 50 - 8

test_df_ = test_df[2005:2205] # 75 - 6

test_df_ = test_df[2205:] # 100 - 5

test_df_ = test_df[:1005]

test_df_ = test_df.copy()

# Commented out IPython magic to ensure Python compatibility.
# %%time
# 
# result = []
# 
# for row in tqdm(test_df_.to_dict('records'), total=len(test_df_), position=0):
#     result.append(process_row(row, pancake_sort_v4, treshold=3, save=False, from_target=False))
# 
# submission_df = pd.DataFrame(result).sort_values('id').reset_index(drop=True)
# 
# print(
#     f'Score: {submission_df.score.sum()} | '
#     f'n: {submission_df.n.sum()} | '
#     f'max len: {max(submission_df.mlen)} | '
#     f'sum max len : {submission_df.mlen.sum()} | '
#     f'total iter: {submission_df.iter.sum()}'
# )
# 
# submission_df.head()

# Score: 16451 | n: 17625 | max len: 6863 | sum max len : 610487 | total iter: 4619036
# CPU times: user 19.7 s, sys: 70 ms, total: 19.8 s
# Wall time: 19.7 s

result = globals().get("result", [])
submission_df = pd.DataFrame(result).sort_values('id').reset_index(drop=True) if result else pd.DataFrame(columns=["id", "solution", "score", "n", "mlen", "iter"])

submission_df_ = globals().get("submission_df_", submission_df)
submission_df.loc[submission_df.score != submission_df_.score]
submission_df_.loc[submission_df.score != submission_df_.score]

# Score: 16439 | n: 17625 | max len: 108282 | sum max len : 4829590 | total iter: 34596637
# CPU times: user 2min 44s, sys: 380 ms, total: 2min 44s
# Wall time: 2min 44s

best_df[1805:1821]

test_df_ = best_df.loc[(best_df.n == 100) & (best_df.score - 3 > best_df.prob_step)]

test_df_

from concurrent.futures import ProcessPoolExecutor, as_completed

rows = test_df_.to_dict('records')
results = []

with ProcessPoolExecutor(max_workers=3) as executor:
    futures = {executor.submit(process_row, perm, pancake_sort_v4,
                               treshold=2.6, save=False, from_target=False) for perm in rows}

    for future in tqdm(as_completed(futures), total=len(futures)):
        results.append(future.result())

# and +
# Score: 16473 | n: 17625 | max len: 5626 | sum max len : 355579 | total iter: 2546273
# and -
# Score: 16473 | n: 17625 | max len: 5626 | sum max len : 355576 | total iter: 2546267
# elif
# Score: 16505 | n: 17625 | max len: 3653 | sum max len : 319540 | total iter: 2278114
# Score: 16494 | n: 17625 | max len: 5135 | sum max len : 321712 | total iter: 2317732

# or -
# Score: 16428 | n: 17625 | max len: 22822 | sum max len : 1620593 | total iter: 11825787
# or +
# Score: 16428 | n: 17625 | max len: 22822 | sum max len : 1620601 | total iter: 11825796
# elif
# Score: 16433 | n: 17625 | max len: 21257 | sum max len : 1588071 | total iter: 11631490

submission_df = pd.DataFrame(results).sort_values('id').reset_index(drop=True)

print(
    f'Score: {submission_df.score.sum()} | '
    f'n: {submission_df.n.sum()} | '
    f'max len: {max(submission_df.mlen)} | '
    f'sum max len : {submission_df.mlen.sum()} | '
    f'total iter: {submission_df.iter.sum()}'
)

submission_df.head()

def check_steps(df):
    for row in df.to_dict('records'):
        perm = parse_permutation(row['permutation'])
        steps = list(map(int, row['solution'].lstrip('R').split('.R')))
        for idx in steps:
            perm[:idx] = perm[:idx][::-1]
        if perm != list(range(len(perm))):
            id_perm = row['id']
            print(f'Wrong solution for id{id_perm}')

check_steps(best_df)

best_df, result = best_solution(submission_df, safe=True)
print(*result.items())

best_df.to_csv(BEST_SUBMISSION_PATH)

best_df[:1005].loc[best_df[:1005].score != submission_df.score]

submission_df.loc[best_df[:1005].score != submission_df.score]

best_df[:1005].loc[best_df[:1005].score != submission_df.score]

submission_df.loc[best_df[:1005].score != submission_df.score]

compare()

# best_df = best_df.set_index('id').join(test_df.set_index('id')[['n']], how='left').reset_index()
# best_sub_df = submission_df.reindex(columns=['id', 'permutation', 'solution', 'score', 'prob_step'])
# best_sub_df.prob_step = best_sub_df.permutation.apply(lambda x: prob_step(parse_permutation(x)))
# best_df.prob_step = best_df.permutation.apply(lambda x: prob_step(parse_permutation(x)))
# best_sub_df.to_csv(BEST_SUBMISSION_PATH)

best_df.prob_step = best_df.permutation.apply(lambda x: prob_step(parse_permutation(x)))

submission_df.to_csv(SUBMISSION_PATH, index=False)
SUBMISSION_PATH, len(submission_df)

out_submission_df = best_df[['id', 'permutation', 'solution']]

out_submission_df.sample(5, random_state=0)

out_submission_df.to_csv(SUBMISSION_PATH, index=False)

SUBMISSION_PATH