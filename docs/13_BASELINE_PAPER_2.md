### Valenzano & Yang 2017: Gap Heuristic for the Pancake Puzzle

**Источник:** Richard Valenzano, Danniel Sihui Yang,  
*An Analysis and Enhancement of the Gap Heuristic for the Pancake Puzzle*, SoCS 2017  
(текст извлечён в `baseline/18433-77-21949-1-2-20210717.md`).

---

### 1. Что за задача

- Исследуется классический **pancake puzzle** как домен для поиска:
  - состояние — перестановка 1..N (стек блинчиков);
  - ход Mi — разворот префикса длины i;
  - цель — минимизировать число ходов до сортировки (1,2,…,N).
- Рассматривается **эвристика gap heuristic** \(h_G\) (Helmert 2010):
  - расширенная перестановка \(\pi^e = [\pi(1),\dots,\pi(N), N+1]\);
  - **adjacency** между позициями j и j+1, если \(|\pi^e[j] - \pi^e[j+1]| = 1\);
  - **gap** — если adjacency нет;
  - \(h_G(\pi)\) = число gap’ов;
  - каждый ход может изменить число gap’ов не более чем на 1 → \(h_G\) **admissible и consistent**.
- Pancake puzzle используется как бенчмарк для IDA\* и других алгоритмов поиска.

---

### 2. Основной вклад статьи

1. **Анализ точности gap heuristic:**
   - показывает, что для случайных перестановок \(h_G\) почти всегда очень точен (ошибка ≤ 2);
   - но существуют состояния, для которых **ошибка линейна по N**.

2. **Новые методы генерации «тяжёлых» задач:**
   - self-inverse permutations;
   - перестановки с короткими циклами (short cycles);
   - bootstrapping (сборка больших задач из меньших hard‑задач).
   - Эти методы дают **новые бенчмарки**, где \(h_G\) сильно недооценивает стоимость.

3. **Топология эвристики и отсутствие локальных минимумов:**
   - классифицируются состояния по **exit distance** (расстояние до ближайшего состояния с меньшей эвристикой);
   - показывается, что для pancake‑домена у \(h_G\) **нет локальных минимумов**, exit distance ≤ 2.

4. **Улучшения эвристики через lookahead и dual:**
   - вводятся **LD (Lock Detection)**, **2LD (Two-Level Lock Detection)** и их dual‑версии (LDD, 2LDD);
   - эти улучшения увеличивают точность оценок и **существенно ускоряют IDA\*** на существующих и новых бенчмарках.

---

### 3. Точность и худшие случаи `h_G`

- Определяется **absolute heuristic error (AHE)**:

  \[
    \text{AHE}_h(\pi) = h^*(\pi) - h(\pi)
  \]

  где \(h^*(\pi)\) — оптимальная стоимость из \(\pi\).

#### 3.1. Случайные перестановки

- Для N = 16..60:
  - 1000 случайных перестановок на каждое N;
  - для каждой считаются \(h_G\) и \(h^*\).
- Выводы:
  - для **33–39%** задач AHE = 0 (идеальная оценка);
  - для **95–99.9%** задач AHE ≤ 1;
  - по таблицам и экспериментам AHE > 3 практически не встречается (на случайных задачах).

#### 3.2. Хуже всего `h_G` может ошибаться линейно по N

- На основе известных результатов по диаметру pancake‑пазла (Heydari & Sudborough, Chitturi et al., Fischer–Ginzinger) выводятся **нижняя и верхняя оценки** худшего AHE:

  \[
    \frac{1}{14}N \le \max_\pi \text{AHE}_{h_G}(\pi) \le \frac{11}{9}N
  \]

- Эксперименты на полном пространстве для N ≤ 12 показывают:
  - фактический максимум AHE = \(\lfloor \frac{N}{2} \rfloor - 1\) для этих N.
- Для больших N используется семейство состояний \(FG_{2N}\) (связано с burnt‑pancake состоянием \(-I_N\)):
  - для ряда N удаётся показать, что AHE достигает значений 8, 9 и т.д.;
  - это подтверждает, что **в худшем случае ошибка растёт линейно по N**.

---

### 4. Генерация тяжёлых бенчмарков

Цель: получить большие наборы задач, где AHE существенно выше, чем на случайных перестановках, чтобы честно тестировать алгоритмы поиска.

#### 4.1. Self-inverse permutations

- Перестановка \(\pi\) самодвойственна, если \(\pi[i] = \pi^D[i]\) для всех i, где \(\pi^D\) — dual.
- Показывается, что такие состояния обычно имеют значительно больший AHE для `h_G`.
- Предлагается простой генератор self‑inverse перестановок:
  - итеративно выбираются пары и одиночки элементов для построения циклов `(i ↔ j)` и `(i → i)`.

#### 4.2. Short cycles

- Используются перестановки, чья циклическая структура состоит только из:
  - циклов длины ≤ 4;
  - каждый цикл покрывает последовательный диапазон чисел (например, {2,3,4,5}), но порядок в цикле может быть произвольным.
- Такие деформации дают состояния с высоким AHE.

#### 4.3. Bootstrapping

- Идея: **строить большие hard‑задачи из меньших hard‑стеках**:
  - берутся два seed‑набора S и S′ для размеров N и N′;
  - формируются новые состояния размера N+N′ путём конкатенации и сдвига (`π ◦ (π′+N)`, `(π+N′) ◦ π′`, и т.п.).
- Эксперименты:
  - для размеров N = 16,20,24,28 собираются по 1000 задач на каждую из 4 методик: Random, Self-Inverse, Short Cycles, Bootstrapping;
  - в таблице AHE видно, что **bootstrapping даёт самые «сложные» наборы** (максимальный AHE и наибольшее среднее).

#### 4.4. Влияние на IDA\*

- На новых бенчмарках IDA\* с \(h_G\) порождает на **порядки больше состояний**, чем на случайных перестановках:
  - это показывает, что такие наборы действительно лучше тестируют поведение поиска при неточной эвристике.

---

### 5. Топология эвристики `h_G` (plateaus, locked states, exit distance)

Ключевой раздел статьи — анализ **топологии** эвристики.

- **Plateau (плато)** — связный набор состояний с одинаковым значением h.
- **Exit** — состояние с меньшим h, достижимое из плато.
- **Exit distance** состояния — минимум ходов до ближайшего exit.
- **Locked state** — состояние, в котором **нет gap‑decreasing ходов** (любой ход не уменьшает число gap’ов).

Основные результаты:

- Введено понятие **Fischer–Ginzinger (FG) states**:
  - состояние делится на **strips** (максимальные подпоследовательности без gap’ов);
  - FG‑состояния: все strips
    - имеют размер ≥2;
    - являются убывающими;
    - идут в порядке возрастания значений (strip’ы «отсортированы по величине»).
- Показано:
  - все FG‑состояния — locked;
  - для любых **не‑FG locked** состояний exit distance = 1;
  - для FG‑состояний:
    - «easy FG» (2 strip’а, правый размером 2): exit distance = 1;
    - «hard FG» (остальные FG): exit distance = 2.
- **Итого:** для любого состояния exit distance ≤ 2, и у `h_G` **нет локальных минимумов**:
  - всегда существует путь к оптимальному решению, идущий только по gap‑neutral/‑decreasing ходам (без необходимости «подниматься в гору» по h).

---

### 6. Улучшения `h_G`: LD, 2LD, LDD, 2LDD

#### 6.1. Lock Detection (LD) — 1‑шаговый lookahead

- Определяется 1‑шаговый lookahead:

  \[
    L^1_G(\pi) = \min_{i} \{ 1 + h_G(M_i(\pi)) \}
  \]

  с учётом случаев, когда цель достигается за ≤1 ход.

- Анализ показывает:
  - если в \(\pi\) есть gap‑decreasing ход, то \(L^1_G(\pi) = h_G(\pi)\);
  - если нет (состояние locked), то \(L^1_G(\pi) = h_G(\pi) + 1\).
- Это можно **вычислить за O(N)**:
  - достаточно один раз просканировать перестановку и проверить наличие ходов, уменьшающих число gap’ов (lock detection);
  - это не требует явной генерации всех потомков.

#### 6.2. Two-Level Lock Detection (2LD) — 2‑шаговый lookahead

- Аналогично вводится 2‑шаговый lookahead \(L^2_G(\pi)\):
  - если существует путь длины 2, уменьшающий h на 2, то \(L^2_G(\pi) = h_G(\pi)\);
  - иначе, если только lock’и ближайшего окружения → \(L^2_G(\pi) = h_G(\pi)+1\) или \(h_G(\pi)+2\) в зависимости от типа FG‑состояния.
- Показано, что благодаря анализу FG‑состояний и их окрестности:
  - **все проверки можно сделать за O(N)**, без генерации O((N−1)²) потомков;
  - используется алгоритм TwoLevelLockCheck (Algorithm 1 в статье), комбинирующий:
    - сканирование по возможным gap‑decreasing ходам;
    - проверку, приводят ли они к locked/non‑locked состояниям на глубине 2.

#### 6.3. Использование dual‑состояния: LDD и 2LDD

- В целом для любой эвристики h можно улучшить оценку как `max(h(π), h(π^D))`, где π^D — dual.
- Для `h_G` само по себе это **ничего не даёт** (h_G(π) = h_G(π^D)), т.к. dual сохраняет adjacency/gap’ы.
- Но для lookahead’ов (LD/2LD) значения **могут отличаться**:
  - пример: π имеет gap‑decreasing ход, π^D может быть locked;
  - значит, `L^1_G(π)` и `L^1_G(π^D)` могут быть разными.
- Определяются:
  - **LDD**: `max(LD(π), LD(π^D))`;
  - **2LDD**: `max(2LD(π), 2LD(π^D))`.
- Поддерживая π и π^D во время поиска (цена — удвоение стоимости применения хода), можно:
  - получить более точные оценки;
  - уменьшить число порождённых узлов в IDA\*.

---

### 7. Экспериментальные результаты

- На наборах:
  - случайные перестановки и
  - новые тяжёлые бенчмарки (Self-Inverse, Short Cycles, Bootstrapping),
  исследуется:
  - AHE (среднее, медиана, максимум, SD);
  - число порождённых узлов IDA\* с эвристиками:
    - h_G,
    - LD, LDD,
    - 2LD, 2LDD.

- Итог:
  - новые генераторы задач дают существенно большие AHE и **экспоненциальный рост** числа узлов для IDA\* с чистым `h_G`;
  - LD/2LD/LDD/2LDD заметно снижают AHE и **существенно ускоряют IDA\*** (меньше узлов, лучше масштабирование по N).

---

### 8. Связь с нашим проектом

Полезные идеи для нас:

- **Уточнение гипотезы H_heuristic:**
  - мы уже используем `gap_h` как одну из эвристик (`src/heuristics/h_functions.py`);
  - работа Valenzano & Yang показывает, что:
    - `gap_h` очень точен на случайных стеках, но в худшем случае сильно недооценивает;
    - существуют конкретные семейства hard‑задач (Self-Inverse, Short Cycles, Bootstrapping), которые стоит использовать как бенчмарки.
  - Для проверки H_heuristic/H_grid логично:
    - генерировать подобные наборы задач и измерять AHE / скор / время.

- **Lookahead и lock detection:**
  - идеи LD/2LD можно перенести в контекст наших эвристик:
    - строить «дешёвый» lookahead по gap_h (или mix_h), не генерируя всех потомков;
    - использовать понятие locked‑состояний и FG‑подобных структур для улучшения оценки.

- **Dual‑состояние:**
  - dual уже используется в теории (Tom Rokicki, здесь — для h_G);
  - в наших beam/heuristics можно рассмотреть комбинирование оценок по π и π^D.

- **Бенчмарки:**
  - генераторы Self-Inverse, Short Cycles, Bootstrapping — источник «тестовых наборов» для:
    - оценки качества наших beam/RL;
    - измерения влияния новых эвристик и стратегий.

В сумме, статья даёт теоретический и практический каркас для гипотез про улучшение `gap_h` и для осмысленного выбора тестовых наборов — это естественное развитие гипотез H_heuristic и H_grid в `docs/03_HYPOTHESES.md`.

